package main

var tmpl = `{{ $dot := . }}
// File generated by gorpgen. DO NOT EDIT.
package {{.Pkg}}

{{- if .Imports }}
import (
{{- range $i := .Imports }}
    "{{$i}}"
{{- end }}
)
{{- end}}

{{- if .Init }}
func init() {
	utils.Tables.Add({{.Name}}{})
}

{{- end }}
var (
{{- range $f, $tf := .Fields }}
	{{$dot.Name}}_{{$f}}    = utils.TableField("{{$dot.Table}}", "{{$tf}}")
{{- end}}
)

{{ if .Rels}}
// Edge names
const (
{{- range $edge, $rel := .Rels}}
    REL_{{$dot.Name | ToUpper}}_{{$edge | ToUpper}} = "{{$edge}}"
{{- end}}
)

// Relation objects
var (
{{- range $edge, $rel := .Rels}}
    Rel_{{$dot.Name}}_{{$rel.Name}}_{{$edge}} = utils.R(new({{$rel.Name}}), "{{$edge}}")
    Rel_{{$rel.Name}}_{{$dot.Name}}_{{$edge}} = utils.R(new({{$dot.Name}}), "{{$edge}}")
{{- end}}
)
{{end}}

{{ if .Muls }}
const (
{{- range $mul := .Muls }}
    MUL_{{$dot.Name | ToUpper}}_{{$mul.Edge | ToUpper}} = "{{$mul.Edge}}"
{{- end}}
)
{{end}}

func (t {{.Name}}) Fields() []string {
	return []string{
{{- range $f, $tf := .Fields }}
		"{{$dot.Table}}.{{$tf}}",
{{- end}}
	}
}

func (t {{.Name}}) TableName() string {
	return "{{.Table}}"
}

func (t {{.Name}}) VersionField() string {
    return "{{.Version}}"
}

func (t {{.Name}}) PK() (*utils.Field, interface{}) {
	return {{.Name}}_{{.ID}}, t.{{.ID}}
}

{{ if .Rels }}
func (t *{{.Name}}) Relation(edge string) (*utils.Field, bool) {
	fm := map[string]*utils.Field{
{{- range $edge, $rel := .Rels }}
	"{{$edge}}": {{$rel.Name}}_{{$rel.Field}},
{{- end }}
    }
    fk, ok := fm[edge]
    return fk, ok
}
{{ else }}
func (t *{{.Name}}) Relation(edge string) (*utils.Field, bool) {
	return nil, false
}
{{- end }}

func (t *{{.Name}}) Load(db gorp.SqlExecutor, pk int64) error {
	return errors.Annotatef(t.Where(
{{- if .Fields.Removed }}
		{{.Name}}_Removed.EQ(false),
{{- end }}
		{{.Name}}_{{.ID}}.EQ(pk),
	).Fetch(db), "pk:%d", pk)
}

// Insert {{.Name}} to db
func (t *{{.Name}}) InsertWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre insert hook error")
		}
	}

	if err := t.Insert(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post insert hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Insert(db gorp.SqlExecutor) error {
{{ if .Fields.CreatedTime }}
	if !t.CreatedTime.Valid {
		t.CreatedTime = utils.Now()
	}
{{- end }}
{{- if .Fields.UpdatedTime }}
	t.UpdatedTime = utils.Now()
{{- end }}
	err := db.Insert(t)
	if err != nil {
		return errors.Annotate(db.Insert(t), t.String())
	}

	return nil
}

// Update {{.Name}} to db
func (t *{{.Name}}) UpdateWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre update hook error")
		}
	}

	if err := t.Update(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post update hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Update(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = utils.Now()
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

// Remove mark {{.Name}} is remove(not actually delete)
{{- if .Fields.Removed }}
func (t *{{.Name}}) RemoveWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre remove hook error")
		}
	}

	if err := t.Remove(db); err != nil {
		return err
	}

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post remove hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Remove(db gorp.SqlExecutor) error {
{{ if .Fields.UpdatedTime }}
	t.UpdatedTime = utils.Now()
{{- end }}
	t.RemovedTime = utils.Now()
{{- if .Fields.Removed }}
	t.Removed = true
{{- end }}
	_, err := db.Update(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}
{{- end }}

// Delete {{.Name}} from db
func (t *{{.Name}}) DeleteWithHooks(db gorp.SqlExecutor, preAndPostHook ...func(t *{{.Name}}) error) error {
	if len(preAndPostHook) > 0 {
		if err := preAndPostHook[0](t); err != nil {
			return errors.Annotatef(err, "pre delete hook error")
		}
	}

	if err := t.Delete(db); err != nil {
		return err
	}	

	if len(preAndPostHook) > 1 {
		if err := preAndPostHook[1](t); err != nil {
			return errors.Annotatef(err, "post delete hook error")
		}
	}

	return nil
}

func (t *{{.Name}}) Delete(db gorp.SqlExecutor) error {
	_, err := db.Delete(t)
	if err != nil {
		return errors.Annotate(err, t.String())
	}

	return nil
}

{{ if .Muls }}
func (t *{{.Name}}) Multiple(edge string) (string, *utils.Field, *utils.Field, bool) {
    switch edge {
{{- range $mul := .Muls }}
    	case "{{$mul.Edge}}":
    		return "{{$mul.TableName}}", {{$mul.Left.Name}}_{{$mul.Left.Field}}, {{$mul.Right.Name}}_{{$mul.Right.Field}}, true
{{- end }}
    }
	return "", nil, nil, false
}
{{ else }}
func (t *{{.Name}}) Multiple(edge string) (string, *utils.Field, *utils.Field, bool) {
	return "", nil, nil, false
}
{{- end }}

func (t *{{.Name}}) Where(cs ...*utils.Condition) *utils.Query {
	return utils.Get(t).Where(cs...)
}
func (t *{{.Name}}) Rel(m utils.Model, edge string) *utils.Query {
	return utils.Get(t).Rel(m, edge)
}
func (t *{{.Name}}) Rels(rs ...*utils.Relation) *utils.Query {
	return utils.Get(t).Rels(rs...)
}
{{- if .Rels}}
// Relations
{{- range $edge, $rel := .Rels}}
func (t *{{$dot.Name}}) Rel_{{$edge}}() *utils.Query {
	return utils.Get(t).Rel(new({{$rel.Name}}), "{{$edge}}")
}
{{- end}}
{{end}}

// json string
func (t *{{$dot.Name}}) String() string {
    bs, _ := json.Marshal(t)
    return string(bs)
}

// pagination
type {{$dot.Name}}PageResp struct {
	*utils.PageResponse
	Data []*{{$dot.Name}} ` + "`" + `db:"data" json:"data"` + "`" + `
}

func (t *{{$dot.Name}}PageResp) String() string {
	bs, _ := json.Marshal(t)
	return string(bs)
}

func Load{{$dot.Name}}Page(tx gorp.SqlExecutor, resp *{{$dot.Name}}PageResp, q *utils.Query, page *utils.Page) error {
	resp.Data = make([]*{{$dot.Name}}, 0)
	total, err := utils.LoadPage(tx, q, page, &resp.Data)
	if err != nil {
		return errors.Trace(err)
	}
	resp.PageResponse = utils.NewPageResponse(page, total, resp.Data)
	return nil
}
`
